---
title: "AccelerAge Bayesian Aft"
author: "Philippe Berends, 3972003"
date: "`r Sys.Date()`"
output: html_document
---

# Import libraries

```{r message=FALSE, warning=FALSE}
source("R/bioage_estimate_median.R")
source("R/gompertz_draw.R")
source("R/weibull_draw.R")
source("R/generate_data.R")
library(tidyverse)
library(MASS)
library(psbcGroup)
```


```{r}
df_sim = generate_data(pop_n = 4000 %>% as.integer(),
                       obs_n = 500,
                       p = 20,  #  number of βs
                       g = 4,  #  β number of groups
                       ltname = "15may",  #  File prefix
                       betafrac = 40,  # Beta shrinking factor VERY SMALL
                       seed = 123,
                       force_recalc = T,  #  Override saved lifetable
                       X_plots = F,
                       a = exp(-9),  # Default: exp(-9)
                       b = 0.085)  # Default = 0.085
# Example of optimal LT
#       t               mrl         
# Min.   :  0.00   Min.   :-0.6544  
# 1st Qu.: 29.34   1st Qu.: 6.8019  
# Median : 58.69   Median :24.6824  
# Mean   : 58.69   Mean   :30.6838  
# 3rd Qu.: 88.03   3rd Qu.:52.1135  
# Max.   :117.37   Max.   :80.9731  
sample_a_bs = function(p_u = 2000, p_l = 2, g_u= 200, g_l = 2, a_u =-50, a_l = -2, b_u = 20, b_l = 0.01, lt_n = 500, n_samples = 10000) {
  as = seq(a_l, a_u, by = -0.2) %>% exp
  bs = seq(b_l, b_u, by = 0.05)
  gs = seq(g_l, g_u, by = 2)
  ps = seq(p_l, p_u, by = 4)
  
  # create grid with only p %% g = 0 combos
  valid_pg_pairs = expand.grid(p = ps, g = gs) %>%
    filter(p %% g == 0)
  
  # Sample from grid
  n_samples = min(n_samples, length(as) * length(bs) * nrow(valid_pg_pairs))

  
  a_indices = sample(length(as), n_samples, replace = TRUE)
  b_indices = sample(length(bs), n_samples, replace = TRUE)
  pg_indices = sample(nrw(valid_pg_pairs), n_samples, replace = TRUE)
  
  # Create result dataframe
  result = data.frame(
    a = as[a_indices],
    b = bs[b_indices],
    p = valid_pg_pairs$p[pg_indices],
    g = valid_pg_pairs$g[pg_indices],
    log_a = log(as[a_indices])
  )
  
  return(result)

}

grid = sample_a_bs() # TODO generate lifetables using parameters, then fit
# model to score derived from parameters to estimate optimal a, b for p, g
# For now, I will just focus on 
```


```{r}
generate_data = function(pop_n, obs_n, p, g, ltname, betafrac, seed, force_recalc, X_plots, a = exp(-9), b = 0.085, X_rho, β_rho, non_zero_betas, X_scale) {
  
  print("Generating βs...")
  betas = generate_betas(p = p, g=g, rho = β_rho, rho_between = 0.2,
                         seed = seed, mu_u = 1, mu_l = -2, beta_scale = 0.5,
                         beta_denom = 20, plot = T, non_zero_groups = non_zero_betas)
  
  # betas$beta = betas$beta + 0.01
  
  
  print("Generating X...")
  X = generate_X(n = pop_n, p = p, g = g, rho = X_rho, seed = seed,
                 rho_between = 0.2,
                 X_plots = X_plots, scale = X_scale)
  print("Done!")
  
  
  print("Generating population lifetable...")
  lt = generate_population_lifetable(N_pop = pop_n, M = p, betas = betas$beta,
                                   X = X$X, filename = ltname,
                                   seed = seed, force_recalc = force_recalc, a=a, b=b)
  print("Done!")
  
  plot = ggplot(lt, aes(x = t, y = mrl)) +
    geom_line() +
    labs(
      title = "Population Lifetable MRL",
      x = "Chronological age (years)",
      y = "Mean Residual Life"
    ) +
    theme_minimal()
  print(plot)
  
  print("Generating data from lifetable...")
  df_sim = create_dataset(M = p, n_obs = obs_n, G = g,
                          gsize = (p/g), lt = lt, betas = betas$beta,
                          seednr = seed+1, X_plots = F, a=a, b=b, X_rho = X_rho,
                          X_scale = X_scale)
  
  return(list(df = df_sim, true_betas = betas))
}
```


```{r}
df_sim = generate_data(pop_n = 10000, obs_n = 500, p = 200, g = 4,
                       ltname = "19may", betafrac = 40, seed = 123,
                       force_recalc = T, X_plots = T, a = exp(-9), b = 0.085,
                       X_rho = 0, β_rho = 0.9, non_zero_betas = 0.75, X_scale = 0.1)
lt = read_rds("pop_lifetable_19may.rds")
true_betas = df_sim$true_betas
df_sim = df_sim$df
```

```{r}
aft_reg = function(df_sim) {
  # Create the formula for AFT regression
  predictor_vars = paste(c(glue("x{1:p}")), collapse = " + ")
  aft_formula = as.formula(paste("Surv(age_start, age_end, status) ~", predictor_vars))
  
  # Fit the AFT model
  fit_aft <- eha::aftreg(formula = aft_formula, 
                          data = df_sim, 
                          dist = "gompertz")
  
  # get estimated parameters
  sigma_est <- exp(fit_aft$coefficients["log(scale)"]) # canonical parametrization
  tau_est <- exp(fit_aft$coefficients["log(shape)"]) # canonical parametrization
  a_est <- tau_est / sigma_est
  b_est <- 1 / sigma_est
  
  betas_est_aft <- fit_aft$coefficients[1:p]
  linpred_aft <- rowSums(sweep(df_sim[,1:p], 2, betas_est_aft, "*"))
  
  for (i in 1:nrow(df_sim)){
    mrl_uncon <- integrate(gomp_baseline_surv, lower = (df_sim$age_start[i] * exp(linpred_aft[i])), 
                           upper=Inf, a = a_est, b = b_est)$value
    s_cond <-  gomp_baseline_surv(df_sim$age_start[i] * exp(linpred_aft[i]), a = a_est, b = b_est) 
    df_sim$pred_mrl[i] <- (mrl_uncon / s_cond) * exp(-linpred_aft[i])
  }
  
  df_sim %>% ggplot(aes(x = mrl, y = pred_mrl)) +
    geom_point() +
    geom_abline(color = 'red') +
    theme_minimal()
  
  # Get the RMSE
  aftreg_rmse = sqrt(mean((df_sim$mrl - df_sim$pred_mrl)^2))
  return(aftreg_rmse)
}

psbc_reg = fuction(df_sim, p, g) {
  Y = cbind(df_sim$age_start, df_sim$age_end, df_sim$status)
  
  # Create covariate matrix X
  X = as.matrix(df_sim[, paste0("x", 1:p)])
  
  XC = NULL # CONFOUNDERS
  
  # Create group indicator for each variable
  grpInx = rep(1:g, each = p/g)  # assuming all variables are in one group (CHANGE?)
  
  # Set hyperparameters
  hyperParams = list(
    a.sigSq = 0.1, b.sigSq = 0.1,
    mu0 = 0, h0 = 0.1,
    v = 0.1
  )
  
  # Set starting values https://cran.r-project.org/web/packages/psbcGroup/psbcGroup.pdf
  w = log(Y[,1])
  mu = 0.1
  beta = rep(2, p)
  sigSq = 0.5
  tauSq = rep(0.4, p)
  lambdaSq = 100
  betaC = rep(0.11, 0)
  startValues = list(w=w, beta=beta, tauSq=tauSq, mu=mu, sigSq=sigSq,
  lambdaSq=lambdaSq, betaC=betaC)
  
  # MCMC parameters format __ CHANGE __ 
  mcmcParams = list(
    run = list(
      numReps = 5000,
      thin = 5,
      burninPerc = 0.2
    ),
    tuning = list(
      mu.prop.var = 0.5,
      sigSq.prop.var = 0.01,
      L.beC = 50,
      M.beC = 1,
      eps.beC = 0.001,
      L.be = 100,
      M.be = 1,
      eps.be = 0.001
    )
  )
  
  fit_bayes_aft = aftGL_LT(Y, X, XC, grpInx, hyperParams, startValues, mcmcParams)
  
  # Extract betas using the maximum likelihood via density
  get_mode = function(x){
    xdist = density(x)
    mode = xdist$x[which.max(xdist$y)]
    return(mode)
  }
  betas = fit_bayes_aft$beta.p %>% apply(MARGIN = 2, FUN = get_mode)
  # Make linear predictor for MRL
  X = df_sim[,1:20] %>% as.matrix
  est_MRL = X %*% betas
  
  # Get RMSE between estimate and actual MRL
  RMSE = sqrt(mean((df_sim$mrl - est_MRL)^2))
  return(RMSE)

}

```


# Generate Covariates and Betas

```{r}
source("R/generate_data.R")
n = 100000
p = 20
g = 4

X = generate_X(n = n, p = p, g = g, constant_in_group =F, rho = 0.9, seed = 123, rho_between = 0.2, non_zero_groups = 0.5, beta_scale = 0.5, beta_denom = 20)
```

# Generate lifetable

$\vec{\beta}$

```{r}
lt = generate_population_lifetable(N_pop = n, M = p, betas = X$betas/40,
                                   X = X$X, filename = "small", seed = 123, force_recalc = F)

ggplot(lt, aes(x = t, y = mrl)) +
    geom_line() +
    labs(
      title = "Mean Residual Life Function",
      x = "Chronological age (years)",
      y = "Mean Residual Life"
    ) +
    theme_minimal()

ggplot(lt, aes(x = mrl)) +
  geom_histogram(fill = "skyblue") +
  labs(
    title = "Distribution of Mean Residul Life (MRL)",
    x = "Mean Residual Life (MRL)"
  ) +
  theme_minimal()
```

$\frac{\vec{\beta}}{20}$

```{r}
lt = generate_population_lifetable(N_pop = n, M = p, betas = X$betas/20,
                                   X = X$X, filename = "div20_small", seed = 123, force_recalc = F)

ggplot(lt, aes(x = t, y = mrl)) +
    geom_line() +
    labs(
      title = "Mean Residual Life Function",
      x = "Chronological age (years)",
      y = "Mean Residual Life"
    ) +
    theme_minimal()

ggplot(lt, aes(x = mrl)) +
  geom_histogram(fill = "skyblue") +
  labs(
    title = "Distribution of Mean Residul Life (MRL)",
    x = "Mean Residual Life (MRL)"
  ) +
  theme_minimal()
```

$\frac{\vec{\beta}}{40}$

```{r}
lt = generate_population_lifetable(N_pop = n, M = p, betas = X$betas/40,
                                   X = X$X, filename = "div40_small", seed = 123, force_recalc = F)

ggplot(lt, aes(x = t, y = mrl)) +
    geom_line() +
    labs(
      title = "Mean Residual Life Function",
      x = "Chronological age (years)",
      y = "Mean Residual Life"
    ) +
    theme_minimal()

ggplot(lt, aes(x = mrl)) +
  geom_histogram(fill = "skyblue") +
  labs(
    title = "Distribution of Mean Residul Life (MRL)",
    x = "Mean Residual Life (MRL)"
  ) +
  theme_minimal()
```

$\frac{\vec{\beta}}{60}$

```{r}
lt = generate_population_lifetable(N_pop = n, M = p, betas = X$betas/60,
                                   X = X$X, filename = "div60_small", seed = 123, force_recalc = F)

ggplot(lt, aes(x = t, y = mrl)) +
    geom_line() +
    labs(
      title = "Mean Residual Life Function",
      x = "Chronological age (years)",
      y = "Mean Residual Life"
    ) +
    theme_minimal()

ggplot(lt, aes(x = mrl)) +
  geom_histogram(fill = "skyblue") +
  labs(
    title = "Distribution of Mean Residul Life (MRL)",
    x = "Mean Residual Life (MRL)"
  ) +
  theme_minimal()
```


$\frac{\vec{\beta}}{80}$

```{r}
lt = generate_population_lifetable(N_pop = n, M = p, betas = X$betas/80,
                                   X = X$X, filename = "div80_small", seed = 123, force_recalc = F)

ggplot(lt, aes(x = t, y = mrl)) +
    geom_line() +
    labs(
      title = "Mean Residual Life Function",
      x = "Chronological age (years)",
      y = "Mean Residual Life"
    ) +
    theme_minimal()

ggplot(lt, aes(x = mrl)) +
  geom_histogram(fill = "skyblue") +
  labs(
    title = "Distribution of Mean Residul Life (MRL)",
    x = "Mean Residual Life (MRL)"
  ) +
  theme_minimal()
```

$\frac{\vec{\beta}}{100}$ (Best?)

```{r}
lt = generate_population_lifetable(N_pop = n, M = p, betas = X$betas/100,
                                   X = X$X, filename = "div100_small", seed = 123, force_recalc = F)

ggplot(lt, aes(x = t, y = mrl)) +
    geom_line() +
    labs(
      title = "Mean Residual Life Function",
      x = "Chronological age (years)",
      y = "Mean Residual Life"
    ) +
    theme_minimal()

ggplot(lt, aes(x = mrl)) +
  geom_histogram(fill = "skyblue") +
  labs(
    title = "Distribution of Mean Residul Life (MRL)",
    x = "Mean Residual Life (MRL)"
  ) +
  theme_minimal()
```


# Generate data from lifetable

```{r}
source("R/generate_data.R")

df_sim = create_dataset(method = "grouped", M = p, n_obs = 500, G = g, gsize = (p/g), lt = lt, betas = X$betas) # Ignore the beta boxplot, old betas are carried over!
```

# Fit AFT AccelerAge

```{r}
# Create the formula for AFT regression
predictor_vars = paste(c(glue("x{1:p}")), collapse = " + ")
aft_formula = as.formula(paste("Surv(age_start, age_end, status) ~", predictor_vars))

# Fit the AFT model
fit_aft <- eha::aftreg(formula = aft_formula, 
                        data = df_sim, 
                        dist = "gompertz")

# get estimated parameters
sigma_est <- exp(fit_aft$coefficients["log(scale)"]) # canonical parametrization
tau_est <- exp(fit_aft$coefficients["log(shape)"]) # canonical parametrization
a_est <- tau_est / sigma_est
b_est <- 1 / sigma_est

betas_est_aft <- fit_aft$coefficients[1:p]
linpred_aft <- rowSums(sweep(df_sim[,1:p], 2, betas_est_aft, "*"))

for (i in 1:nrow(df_sim)){
  mrl_uncon <- integrate(gomp_baseline_surv, lower = (df_sim$age_start[i] * exp(linpred_aft[i])), 
                         upper=Inf, a = a_est, b = b_est)$value
  s_cond <-  gomp_baseline_surv(df_sim$age_start[i] * exp(linpred_aft[i]), a = a_est, b = b_est) 
  df_sim$pred_mrl[i] <- (mrl_uncon / s_cond) * exp(-linpred_aft[i])
}
```


```{r}
df_sim %>% ggplot(aes(x = pred_mrl, y = mrl)) +
  geom_point() +
  geom_abline()
```

```{r}
Y = cbind(df_sim$age_start, df_sim$age_end, df_sim$status)

# Create covariate matrix X
X = as.matrix(df_sim[, paste0("x", 1:p)])

XC = NULL # CONFOUNDERS

# Create group indicator for each variable
grpInx = rep(1, p)  # assuming all variables are in one group (CHANGE?)

# Set hyperparameters
hyperParams = list(
  a.sigSq = 0.1, b.sigSq = 0.1,
  mu0 = 0, h0 = 0.1,
  v = 0.1
)

# Set starting values https://cran.r-project.org/web/packages/psbcGroup/psbcGroup.pdf
w = log(Y[,1])
mu = 0.1
beta = rep(2, p)
sigSq = 0.5
tauSq = rep(0.4, p)
lambdaSq = 100
betaC = rep(0.11, 0)
startValues = list(w=w, beta=beta, tauSq=tauSq, mu=mu, sigSq=sigSq,
lambdaSq=lambdaSq, betaC=betaC)

# MCMC parameters format
mcmcParams = list(
  run = list(
    numReps = 5000,
    thin = 5,
    burninPerc = 0.2
  ),
  tuning = list(
    mu.prop.var = 0.5,
    sigSq.prop.var = 0.01,
    L.beC = 50,
    M.beC = 1,
    eps.beC = 0.001,
    L.be = 100,
    M.be = 1,
    eps.be = 0.001
  )
)

fit_bayes_aft = aftGL_LT(Y, X, XC, grpInx, hyperParams, startValues, mcmcParams)


```

